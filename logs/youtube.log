2025-08-19 12:31:21,959 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:31:22,059 - __streamlit_app__ - INFO - Chargement du modèle d'embedding...
2025-08-19 12:31:22,059 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:31:29,371 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:31:29,371 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:31:34,829 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:31:34,830 - __streamlit_app__ - INFO - Modèle d'embedding chargé avec succès
2025-08-19 12:31:35,213 - __streamlit_app__ - INFO - Initialisation du client Qdrant...
2025-08-19 12:31:36,042 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:31:36,425 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:31:36,437 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:31:36,437 - __streamlit_app__ - INFO - Client Qdrant initialisé
2025-08-19 12:31:36,441 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:31:36,446 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:32:14,142 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:32:14,163 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:32:14,175 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:32:14,178 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:32:14,178 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:32:14,588 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:32:14,598 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ non trouvée, démarrage de l'ingestion...
2025-08-19 12:32:14,599 - __streamlit_app__ - INFO - Récupération de la transcription pour WMeOZAHusGQ
2025-08-19 12:32:16,214 - __streamlit_app__ - INFO - Transcription récupérée (180 segments)
2025-08-19 12:32:16,216 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour WMeOZAHusGQ
2025-08-19 12:32:16,217 - __streamlit_app__ - INFO - Traitement et stockage de WMeOZAHusGQ dans Qdrant
2025-08-19 12:32:16,217 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:32:16,218 - __embedding__ - ERROR - File not found: ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:32:16,218 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ traitée et stockée avec succès
2025-08-19 12:32:16,220 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:32:26,041 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:32:26,051 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:32:26,054 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:32:26,055 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:32:26,055 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:32:26,440 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:32:26,443 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ non trouvée, démarrage de l'ingestion...
2025-08-19 12:32:26,445 - __streamlit_app__ - INFO - Récupération de la transcription pour WMeOZAHusGQ
2025-08-19 12:32:27,685 - __streamlit_app__ - INFO - Transcription récupérée (180 segments)
2025-08-19 12:32:27,687 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour WMeOZAHusGQ
2025-08-19 12:32:27,688 - __streamlit_app__ - INFO - Traitement et stockage de WMeOZAHusGQ dans Qdrant
2025-08-19 12:32:27,689 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:32:27,689 - __embedding__ - ERROR - File not found: ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:32:27,689 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ traitée et stockée avec succès
2025-08-19 12:32:27,691 - __streamlit_app__ - INFO - Question utilisateur: De quoi parle la vidéo ?
2025-08-19 12:32:27,693 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: De quoi parle la vidéo ?
2025-08-19 12:32:27,694 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'De quoi parle la vidéo ?'
2025-08-19 12:32:27,694 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:32:27,703 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:32:27,703 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:32:33,085 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:32:34,790 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:32:35,195 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:32:35,202 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:32:35,202 - __retrieve__ - INFO - Application du filtre pour la vidéo : WMeOZAHusGQ
2025-08-19 12:32:35,202 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:32:35,453 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:32:35,458 - __retrieve__ - INFO - Retrieved 0 relevant chunks.
2025-08-19 12:32:35,459 - __streamlit_app__ - INFO - Trouvé 0 chunks pertinents
2025-08-19 12:32:35,463 - __streamlit_app__ - INFO - Aucun chunk pertinent trouvé pour la requête
2025-08-19 12:32:36,282 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:36:40,236 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:36:40,253 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:36:40,256 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:36:40,257 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:36:40,258 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:36:40,661 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:36:40,667 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:36:40,668 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:36:42,337 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:36:42,338 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:36:42,339 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:36:42,340 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:36:42,340 - __embedding__ - ERROR - File not found: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:36:42,340 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:36:42,344 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:36:46,192 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:36:46,196 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:36:46,198 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:36:46,199 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:36:46,199 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:36:46,578 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:36:46,579 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:36:46,580 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:36:48,293 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:36:48,294 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:36:48,294 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:36:48,294 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:36:48,295 - __embedding__ - ERROR - File not found: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:36:48,295 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:36:48,299 - __streamlit_app__ - INFO - Réinitialisation de la conversation demandée
2025-08-19 12:36:48,505 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:36:48,506 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:36:48,507 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:36:48,507 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:36:48,507 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:36:48,635 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:36:48,640 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:36:48,640 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:36:50,473 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:36:50,474 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:36:50,475 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:36:50,475 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:36:50,475 - __embedding__ - ERROR - File not found: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:36:50,475 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:36:50,477 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:37:00,512 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:37:00,521 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:37:00,523 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:37:00,524 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:37:00,524 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:37:00,913 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:37:00,915 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:37:00,918 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:37:02,941 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:37:02,942 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:37:02,943 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:37:02,943 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:37:02,944 - __embedding__ - ERROR - File not found: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:37:02,944 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:37:02,945 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:37:06,194 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:37:06,195 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:37:06,196 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:37:08,969 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:37:08,975 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:37:08,978 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:37:08,979 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:37:08,980 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:37:09,355 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:37:09,357 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:37:09,359 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:37:11,146 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:37:11,147 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:37:11,148 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:37:11,148 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:37:11,148 - __embedding__ - ERROR - File not found: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:37:11,148 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:37:11,150 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:37:19,179 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:37:19,187 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:37:19,190 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:37:19,191 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:37:19,191 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:37:19,585 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:37:19,590 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:37:19,592 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:37:21,375 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:37:21,376 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:37:21,378 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:37:21,378 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:37:21,378 - __embedding__ - ERROR - File not found: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:37:21,378 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:37:21,380 - __streamlit_app__ - INFO - Question utilisateur: De quoi parle la vidéo ?
2025-08-19 12:37:21,382 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: De quoi parle la vidéo ?
2025-08-19 12:37:21,382 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'De quoi parle la vidéo ?'
2025-08-19 12:37:21,382 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:37:21,389 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:37:21,389 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:37:27,091 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:37:27,777 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:37:28,155 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:37:28,157 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:37:28,158 - __retrieve__ - INFO - Application du filtre pour la vidéo : QSFq8S_Ui5g
2025-08-19 12:37:28,158 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:37:28,403 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:37:28,407 - __retrieve__ - INFO - Retrieved 0 relevant chunks.
2025-08-19 12:37:28,408 - __streamlit_app__ - INFO - Trouvé 0 chunks pertinents
2025-08-19 12:37:28,411 - __streamlit_app__ - INFO - Aucun chunk pertinent trouvé pour la requête
2025-08-19 12:37:29,240 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:41:58,441 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:41:58,446 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:41:58,449 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:42:02,361 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:42:02,377 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:42:02,381 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:42:02,383 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:42:02,383 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:42:03,659 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:42:03,664 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g non trouvée, démarrage de l'ingestion...
2025-08-19 12:42:03,665 - __streamlit_app__ - INFO - Récupération de la transcription pour QSFq8S_Ui5g
2025-08-19 12:42:05,819 - __streamlit_app__ - INFO - Transcription récupérée (3281 segments)
2025-08-19 12:42:05,821 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour QSFq8S_Ui5g
2025-08-19 12:42:05,821 - __youtube__ - INFO - Saving TXT to QSFq8S_Ui5g.txt
2025-08-19 12:42:05,823 - __youtube__ - INFO - Saved TXT to ../downloads/QSFq8S_Ui5g.txt
2025-08-19 12:42:05,823 - __streamlit_app__ - INFO - Transcription sauvegardée dans ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:42:05,823 - __streamlit_app__ - INFO - Traitement et stockage de QSFq8S_Ui5g dans Qdrant
2025-08-19 12:42:05,824 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:42:05,825 - __embedding__ - INFO - Loaded text from ./downloads/QSFq8S_Ui5g.txt, length: 124357 chars
2025-08-19 12:42:05,825 - __embedding__ - INFO - Splitting text into chunks (size=700, overlap=100)
2025-08-19 12:42:05,832 - __embedding__ - INFO - Text split into 205 chunks
2025-08-19 12:42:05,832 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:42:05,838 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:42:05,838 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:42:12,847 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:42:12,848 - __embedding__ - INFO - Embedding 205 text chunks
2025-08-19 12:42:19,200 - __embedding__ - INFO - Embedded 205 text chunks
2025-08-19 12:42:19,677 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:42:20,077 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:42:20,079 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:42:20,207 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:42:20,208 - __qdrant__ - INFO - Collection 'youtube_transcripts' already exists.
2025-08-19 12:42:20,208 - __qdrant__ - INFO - Upserting 205 points into collection 'youtube_transcripts'
2025-08-19 12:42:26,377 - httpx - INFO - HTTP Request: PUT https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points?wait=true "HTTP/1.1 200 OK"
2025-08-19 12:42:26,385 - __qdrant__ - INFO - Successfully upserted points into collection 'youtube_transcripts'
2025-08-19 12:42:26,385 - __embedding__ - INFO - Finished processing and storing 205 chunks from ./downloads/QSFq8S_Ui5g.txt
2025-08-19 12:42:26,390 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g traitée et stockée avec succès
2025-08-19 12:42:26,774 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:42:26,776 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g confirmée dans Qdrant
2025-08-19 12:42:26,787 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:42:37,480 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:42:37,494 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:42:37,505 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:42:37,507 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:42:37,508 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:42:37,905 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:42:37,908 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g déjà présente dans la base
2025-08-19 12:42:37,911 - __streamlit_app__ - INFO - Question utilisateur: De quoi parle la vidéo ?
2025-08-19 12:42:37,918 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: De quoi parle la vidéo ?
2025-08-19 12:42:37,919 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'De quoi parle la vidéo ?'
2025-08-19 12:42:37,920 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:42:37,926 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:42:37,926 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:42:42,780 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:42:43,301 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:42:43,676 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:42:43,678 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:42:43,678 - __retrieve__ - INFO - Application du filtre pour la vidéo : QSFq8S_Ui5g
2025-08-19 12:42:43,679 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:42:43,920 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:42:43,923 - __retrieve__ - INFO - Retrieved 5 relevant chunks.
2025-08-19 12:42:43,924 - __streamlit_app__ - INFO - Trouvé 5 chunks pertinents
2025-08-19 12:42:43,929 - __streamlit_app__ - INFO - Génération de réponse avec le modèle openai/gpt-oss-120b
2025-08-19 12:42:43,929 - __query__ - INFO - Construction du prompt pour la question: 'Contexte de la conversation:
user: De quoi parle la vidéo ?

Question actuelle: De quoi parle la vidéo ?'
2025-08-19 12:42:43,929 - __query__ - INFO - Appel à Groq pour générer la réponse...
2025-08-19 12:42:43,930 - __grok__ - INFO - Generating answer with Groq model 'openai/gpt-oss-120b'
2025-08-19 12:42:43,946 - __grok__ - INFO - Groq client created
2025-08-19 12:42:46,149 - httpx - INFO - HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-19 12:42:46,177 - __grok__ - INFO - Answer generated successfully.
2025-08-19 12:42:46,177 - __query__ - INFO - Réponse générée avec succès.
2025-08-19 12:42:46,177 - __streamlit_app__ - INFO - Réponse générée avec succès
2025-08-19 12:42:51,794 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:43:37,532 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:43:37,550 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:43:37,552 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:43:37,554 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:43:37,554 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:43:37,982 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:43:37,989 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g déjà présente dans la base
2025-08-19 12:43:37,994 - __streamlit_app__ - INFO - Question utilisateur: Bien. C'est quoi le format de fichier recommandé par la vidéo dans le cas d'un projet de data eng ?
2025-08-19 12:43:37,998 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: Bien. C'est quoi le format de fichier recommandé par la vidéo dans le cas d'un projet de data eng ?
2025-08-19 12:43:37,998 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'Bien. C'est quoi le format de fichier recommandé par la vidéo dans le cas d'un projet de data eng ?'
2025-08-19 12:43:37,998 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:43:38,009 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:43:38,009 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:43:42,617 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:43:44,412 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:43:44,798 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:43:44,799 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:43:44,799 - __retrieve__ - INFO - Application du filtre pour la vidéo : QSFq8S_Ui5g
2025-08-19 12:43:44,800 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:43:45,047 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:43:45,053 - __retrieve__ - INFO - Retrieved 5 relevant chunks.
2025-08-19 12:43:45,055 - __streamlit_app__ - INFO - Trouvé 5 chunks pertinents
2025-08-19 12:43:45,065 - __streamlit_app__ - INFO - Génération de réponse avec le modèle openai/gpt-oss-120b
2025-08-19 12:43:45,065 - __query__ - INFO - Construction du prompt pour la question: 'Contexte de la conversation:
user: De quoi parle la vidéo ?
assistant: La vidéo porte sur les notions de base du **big data** : les différents formats de fichiers (JSON, CSV, Avro, Parquet), les types de données (structurées, semi‑structurées, non structurées), le fonctionnement du calcul distribué et du stockage sur du matériel « commodity » en cluster. Elle explique ensuite les **stratégies d’ingestion de données** (chargement incrémentiel, chargement complet, chargement « absurde ») et montre comment mettre en œuvre un chargement incrémentiel avec **Apache Spark** depuis une base MySQL, en appliquant les logiques métier, de déduplication, de filtrage et de validation. Enfin, elle donne quelques conseils pour rédiger les descriptions de projets sur un CV.La vidéo porte sur les notions de base du **big data** : les différents formats de fichiers (JSON, CSV, Avro, Parquet), les types de données (structurées, semi‑structurées, non structurées), le fonctionnement du calcul distribué et du stockage sur du matériel « commodity » en cluster. Elle explique ensuite les **stratégies d’ingestion de données** (chargement incrémentiel, chargement complet, chargement « absurde ») et montre comment mettre en œuvre un chargement incrémentiel avec **Apache Spark** depuis une base MySQL, en appliquant les logiques métier, de déduplication, de filtrage et de validation. Enfin, elle donne quelques conseils pour rédiger les descriptions de projets sur un CV. 
user: Bien. C'est quoi le format de fichier recommandé par la vidéo dans le cas d'un projet de data eng ?

Question actuelle: Bien. C'est quoi le format de fichier recommandé par la vidéo dans le cas d'un projet de data eng ?'
2025-08-19 12:43:45,067 - __query__ - INFO - Appel à Groq pour générer la réponse...
2025-08-19 12:43:45,067 - __grok__ - INFO - Generating answer with Groq model 'openai/gpt-oss-120b'
2025-08-19 12:43:45,087 - __grok__ - INFO - Groq client created
2025-08-19 12:43:45,933 - httpx - INFO - HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-19 12:43:45,937 - __grok__ - INFO - Answer generated successfully.
2025-08-19 12:43:45,937 - __query__ - INFO - Réponse générée avec succès.
2025-08-19 12:43:45,938 - __streamlit_app__ - INFO - Réponse générée avec succès
2025-08-19 12:43:46,495 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:44:02,282 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:44:02,291 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:44:02,298 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:44:02,299 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:44:02,299 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:44:02,687 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:44:02,689 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g déjà présente dans la base
2025-08-19 12:44:02,695 - __streamlit_app__ - INFO - Question utilisateur: quelle était la question précédente ?
2025-08-19 12:44:02,697 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: quelle était la question précédente ?
2025-08-19 12:44:02,698 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'quelle était la question précédente ?'
2025-08-19 12:44:02,699 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:44:02,703 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:44:02,703 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:44:07,460 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:44:08,400 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:44:08,774 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:44:08,777 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:44:08,777 - __retrieve__ - INFO - Application du filtre pour la vidéo : QSFq8S_Ui5g
2025-08-19 12:44:08,777 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:44:09,022 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:44:09,024 - __retrieve__ - INFO - Retrieved 5 relevant chunks.
2025-08-19 12:44:09,025 - __streamlit_app__ - INFO - Trouvé 5 chunks pertinents
2025-08-19 12:44:09,033 - __streamlit_app__ - INFO - Génération de réponse avec le modèle openai/gpt-oss-120b
2025-08-19 12:44:09,033 - __query__ - INFO - Construction du prompt pour la question: 'Contexte de la conversation:
assistant: La vidéo porte sur les notions de base du **big data** : les différents formats de fichiers (JSON, CSV, Avro, Parquet), les types de données (structurées, semi‑structurées, non structurées), le fonctionnement du calcul distribué et du stockage sur du matériel « commodity » en cluster. Elle explique ensuite les **stratégies d’ingestion de données** (chargement incrémentiel, chargement complet, chargement « absurde ») et montre comment mettre en œuvre un chargement incrémentiel avec **Apache Spark** depuis une base MySQL, en appliquant les logiques métier, de déduplication, de filtrage et de validation. Enfin, elle donne quelques conseils pour rédiger les descriptions de projets sur un CV.La vidéo porte sur les notions de base du **big data** : les différents formats de fichiers (JSON, CSV, Avro, Parquet), les types de données (structurées, semi‑structurées, non structurées), le fonctionnement du calcul distribué et du stockage sur du matériel « commodity » en cluster. Elle explique ensuite les **stratégies d’ingestion de données** (chargement incrémentiel, chargement complet, chargement « absurde ») et montre comment mettre en œuvre un chargement incrémentiel avec **Apache Spark** depuis une base MySQL, en appliquant les logiques métier, de déduplication, de filtrage et de validation. Enfin, elle donne quelques conseils pour rédiger les descriptions de projets sur un CV. 
user: Bien. C'est quoi le format de fichier recommandé par la vidéo dans le cas d'un projet de data eng ?
assistant: Je ne trouve pas d'information pertinente dans les transcriptions fournies.Je ne trouve pas d'information pertinente dans les transcriptions fournies. 
user: quelle était la question précédente ?

Question actuelle: quelle était la question précédente ?'
2025-08-19 12:44:09,035 - __query__ - INFO - Appel à Groq pour générer la réponse...
2025-08-19 12:44:09,035 - __grok__ - INFO - Generating answer with Groq model 'openai/gpt-oss-120b'
2025-08-19 12:44:09,050 - __grok__ - INFO - Groq client created
2025-08-19 12:44:10,418 - httpx - INFO - HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-19 12:44:10,422 - __grok__ - INFO - Answer generated successfully.
2025-08-19 12:44:10,422 - __query__ - INFO - Réponse générée avec succès.
2025-08-19 12:44:10,423 - __streamlit_app__ - INFO - Réponse générée avec succès
2025-08-19 12:44:11,916 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:53:02,077 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:53:02,098 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:53:02,107 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:53:02,107 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:53:02,107 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:53:02,767 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:53:02,772 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g déjà présente dans la base
2025-08-19 12:53:02,780 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:53:06,126 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:53:06,134 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:53:06,140 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:53:06,141 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:53:06,141 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:53:06,273 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:53:06,276 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g déjà présente dans la base
2025-08-19 12:53:06,284 - __streamlit_app__ - INFO - Réinitialisation de la conversation demandée
2025-08-19 12:53:06,465 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:53:06,466 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:53:06,467 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:53:06,468 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=QSFq8S_Ui5g
2025-08-19 12:53:06,468 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo QSFq8S_Ui5g dans Qdrant...
2025-08-19 12:53:06,595 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:53:06,597 - __streamlit_app__ - INFO - Vidéo QSFq8S_Ui5g déjà présente dans la base
2025-08-19 12:53:06,598 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:53:26,586 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:53:26,588 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:53:26,594 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:53:29,703 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:53:29,706 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:53:29,711 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:53:29,712 - __youtube__ - INFO - Extracting video ID from URL: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:53:29,712 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:53:30,127 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:53:30,129 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ non trouvée, démarrage de l'ingestion...
2025-08-19 12:53:30,130 - __streamlit_app__ - INFO - Récupération de la transcription pour WMeOZAHusGQ
2025-08-19 12:53:31,569 - __streamlit_app__ - INFO - Transcription récupérée (180 segments)
2025-08-19 12:53:31,572 - __streamlit_app__ - INFO - Sauvegarde de la transcription pour WMeOZAHusGQ
2025-08-19 12:53:31,572 - __youtube__ - INFO - Saving TXT to WMeOZAHusGQ.txt
2025-08-19 12:53:31,573 - __youtube__ - INFO - Saved TXT to ../downloads/WMeOZAHusGQ.txt
2025-08-19 12:53:31,573 - __streamlit_app__ - INFO - Transcription sauvegardée dans ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:53:31,574 - __streamlit_app__ - INFO - Traitement et stockage de WMeOZAHusGQ dans Qdrant
2025-08-19 12:53:31,575 - __embedding__ - INFO - Starting processing for TXT file: ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:53:31,576 - __embedding__ - INFO - Loaded text from ./downloads/WMeOZAHusGQ.txt, length: 6220 chars
2025-08-19 12:53:31,576 - __embedding__ - INFO - Splitting text into chunks (size=700, overlap=100)
2025-08-19 12:53:31,578 - __embedding__ - INFO - Text split into 11 chunks
2025-08-19 12:53:31,578 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:53:31,581 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:53:31,582 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:53:39,615 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:53:39,619 - __embedding__ - INFO - Embedding 11 text chunks
2025-08-19 12:53:43,065 - __embedding__ - INFO - Embedded 11 text chunks
2025-08-19 12:53:43,501 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:53:43,874 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:53:43,876 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:53:44,004 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:53:44,004 - __qdrant__ - INFO - Collection 'youtube_transcripts' already exists.
2025-08-19 12:53:44,004 - __qdrant__ - INFO - Upserting 11 points into collection 'youtube_transcripts'
2025-08-19 12:53:44,643 - httpx - INFO - HTTP Request: PUT https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points?wait=true "HTTP/1.1 200 OK"
2025-08-19 12:53:44,646 - __qdrant__ - INFO - Successfully upserted points into collection 'youtube_transcripts'
2025-08-19 12:53:44,646 - __embedding__ - INFO - Finished processing and storing 11 chunks from ./downloads/WMeOZAHusGQ.txt
2025-08-19 12:53:45,070 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:53:45,071 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ confirmée dans Qdrant
2025-08-19 12:53:45,076 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:53:58,448 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:53:58,461 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:53:58,468 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:53:58,469 - __youtube__ - INFO - Extracting video ID from URL: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:53:58,470 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:53:58,851 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:53:58,854 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ déjà présente dans la base
2025-08-19 12:53:58,855 - __streamlit_app__ - INFO - Question utilisateur: What's about the video ?
2025-08-19 12:53:58,858 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: What's about the video ?
2025-08-19 12:53:58,859 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'What's about the video ?'
2025-08-19 12:53:58,859 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:53:58,863 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:53:58,863 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:54:03,653 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:54:04,193 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:54:04,569 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:54:04,570 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:54:04,570 - __retrieve__ - INFO - Application du filtre pour la vidéo : WMeOZAHusGQ
2025-08-19 12:54:04,570 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:54:04,809 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:54:04,812 - __retrieve__ - INFO - Retrieved 5 relevant chunks.
2025-08-19 12:54:04,813 - __streamlit_app__ - INFO - Trouvé 5 chunks pertinents
2025-08-19 12:54:04,814 - __streamlit_app__ - INFO - Génération de réponse avec le modèle openai/gpt-oss-120b
2025-08-19 12:54:04,814 - __query__ - INFO - Construction du prompt pour la question: 'What's about the video ?'
2025-08-19 12:54:04,815 - __query__ - INFO - Appel à Grok pour générer la réponse...
2025-08-19 12:54:04,815 - __grok__ - INFO - Generating answer with Groq model 'openai/gpt-oss-120b'
2025-08-19 12:54:04,823 - __grok__ - INFO - Groq client created
2025-08-19 12:54:07,040 - httpx - INFO - HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-19 12:54:07,047 - __grok__ - INFO - Answer generated successfully.
2025-08-19 12:54:07,047 - __query__ - INFO - Réponse générée avec succès.
2025-08-19 12:54:07,047 - __streamlit_app__ - INFO - Réponse générée avec succès
2025-08-19 12:54:26,546 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:54:42,459 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:54:42,467 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:54:42,473 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:54:42,474 - __youtube__ - INFO - Extracting video ID from URL: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:54:42,475 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:54:42,690 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:54:42,693 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:54:42,697 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:54:42,697 - __youtube__ - INFO - Extracting video ID from URL: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:54:42,697 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:54:42,864 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:54:43,200 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:54:43,201 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ déjà présente dans la base
2025-08-19 12:54:43,204 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 12:55:32,564 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 12:55:32,579 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 12:55:32,585 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:55:32,586 - __youtube__ - INFO - Extracting video ID from URL: www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 12:55:32,586 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo WMeOZAHusGQ dans Qdrant...
2025-08-19 12:55:33,010 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 200 OK"
2025-08-19 12:55:33,012 - __streamlit_app__ - INFO - Vidéo WMeOZAHusGQ déjà présente dans la base
2025-08-19 12:55:33,017 - __streamlit_app__ - INFO - Question utilisateur: Ok. dis moi quelles technologies on retrouve dans le projet :  stockage, source, ingestion, traitement, visualisation , ?
2025-08-19 12:55:33,019 - __streamlit_app__ - INFO - Recherche de chunks pertinents pour: Ok. dis moi quelles technologies on retrouve dans le projet :  stockage, source, ingestion, traitement, visualisation , ?
2025-08-19 12:55:33,020 - __retrieve__ - INFO - Recherche de chunks pertinents pour la requête : 'Ok. dis moi quelles technologies on retrouve dans le projet :  stockage, source, ingestion, traitement, visualisation , ?'
2025-08-19 12:55:33,021 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 12:55:33,027 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 12:55:33,027 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 12:55:37,873 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 12:55:38,420 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 12:55:38,821 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 12:55:38,822 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[CollectionDescription(name='youtube_transcripts')]
2025-08-19 12:55:38,823 - __retrieve__ - INFO - Application du filtre pour la vidéo : WMeOZAHusGQ
2025-08-19 12:55:38,823 - __retrieve__ - INFO - Lancement de la recherche dans la collection 'youtube_transcripts'
2025-08-19 12:55:39,074 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/search "HTTP/1.1 200 OK"
2025-08-19 12:55:39,079 - __retrieve__ - INFO - Retrieved 5 relevant chunks.
2025-08-19 12:55:39,080 - __streamlit_app__ - INFO - Trouvé 5 chunks pertinents
2025-08-19 12:55:39,084 - __streamlit_app__ - INFO - Génération de réponse avec le modèle openai/gpt-oss-120b
2025-08-19 12:55:39,085 - __query__ - INFO - Construction du prompt pour la question: 'Ok. dis moi quelles technologies on retrouve dans le projet :  stockage, source, ingestion, traitement, visualisation , ?'
2025-08-19 12:55:39,085 - __query__ - INFO - Appel à Grok pour générer la réponse...
2025-08-19 12:55:39,086 - __grok__ - INFO - Generating answer with Groq model 'openai/gpt-oss-120b'
2025-08-19 12:55:39,102 - __grok__ - INFO - Groq client created
2025-08-19 12:55:41,285 - httpx - INFO - HTTP Request: POST https://api.groq.com/openai/v1/chat/completions "HTTP/1.1 200 OK"
2025-08-19 12:55:41,289 - __grok__ - INFO - Answer generated successfully.
2025-08-19 12:55:41,289 - __query__ - INFO - Réponse générée avec succès.
2025-08-19 12:55:41,289 - __streamlit_app__ - INFO - Réponse générée avec succès
2025-08-19 12:55:58,272 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 13:05:16,077 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:05:16,190 - __streamlit_app__ - INFO - Chargement du modèle d'embedding...
2025-08-19 13:05:16,190 - __embedding__ - INFO - Loading model sentence-transformers/all-mpnet-base-v2
2025-08-19 13:05:25,270 - sentence_transformers.SentenceTransformer - INFO - Use pytorch device_name: mps
2025-08-19 13:05:25,271 - sentence_transformers.SentenceTransformer - INFO - Load pretrained SentenceTransformer: sentence-transformers/all-mpnet-base-v2
2025-08-19 13:05:30,535 - __embedding__ - INFO - Model sentence-transformers/all-mpnet-base-v2 loaded
2025-08-19 13:05:30,537 - __streamlit_app__ - INFO - Modèle d'embedding chargé avec succès
2025-08-19 13:05:30,550 - __streamlit_app__ - INFO - Initialisation du client Qdrant...
2025-08-19 13:05:31,098 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333 "HTTP/1.1 200 OK"
2025-08-19 13:05:31,809 - httpx - INFO - HTTP Request: GET https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections "HTTP/1.1 200 OK"
2025-08-19 13:05:31,818 - __qdrant__ - INFO - Connected to Qdrant. Collections: collections=[]
2025-08-19 13:05:31,819 - __streamlit_app__ - INFO - Client Qdrant initialisé
2025-08-19 13:05:31,823 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:05:31,832 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 13:05:38,255 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:05:38,300 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:05:38,306 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: # streamlit_app.py - Version complète mise à jour  import streamlit as st from src.youtube import extract_video_id, get_available_transcript_languages, save_txt_with_language from src.embedding import process_and_store_transcript_txt from src.qdrant import get_qdrant_client, check_video_exists from src.retrieve import retrieve_relevant_chunks from src.query import answer_question_with_grok from src.embedding import get_embedding_model from youtube_transcript_api import YouTubeTranscriptApi from src.loggings import configure_logging import os import time  # Configuration du logging logger = configure_logging(log_file="streamlit_app.log", logger_name="__streamlit_app__") logger.info("Démarrage de l'application Streamlit")  # Configuration de la page st.set_page_config(     page_title="Naive RAG YouTube",     page_icon="🎥",     layout="wide" )  # === CACHING DES MODELES === @st.cache_resource def load_embedding_model():     """Charge le modèle d'embedding au démarrage et le garde en cache"""     with st.spinner("Chargement du modèle d'embedding..."):         logger.info("Chargement du modèle d'embedding...")         model = get_embedding_model()         logger.info("Modèle d'embedding chargé avec succès")         return model  @st.cache_resource def get_qdrant_client_cached():     """Cache le client Qdrant"""     logger.info("Initialisation du client Qdrant...")     client = get_qdrant_client()     logger.info("Client Qdrant initialisé")     return client  # === CONSTANTES === COLLECTION_NAME = "youtube_transcripts" AVAILABLE_MODELS = [     "openai/gpt-oss-120b",     "openai/gpt-oss-20b",      "qwen/qwen3-32b" ] DEFAULT_MODEL = "openai/gpt-oss-120b" DEFAULT_TEMPERATURE = 0.7 DEFAULT_MAX_TOKENS = 1000 DEFAULT_LANGUAGE = "en"  # === INITIALISATION === if 'messages' not in st.session_state:     st.session_state.messages = []     logger.debug("Initialisation de st.session_state.messages") if 'current_video_id' not in st.session_state:     st.session_state.current_video_id = None     logger.debug("Initialisation de st.session_state.current_video_id") if 'video_processed' not in st.session_state:     st.session_state.video_processed = False     logger.debug("Initialisation de st.session_state.video_processed") if 'temperature' not in st.session_state:     st.session_state.temperature = DEFAULT_TEMPERATURE     logger.debug("Initialisation de st.session_state.temperature") if 'max_tokens' not in st.session_state:     st.session_state.max_tokens = DEFAULT_MAX_TOKENS     logger.debug("Initialisation de st.session_state.max_tokens") if 'selected_language' not in st.session_state:     st.session_state.selected_language = DEFAULT_LANGUAGE     logger.debug("Initialisation de st.session_state.selected_language") if 'available_languages' not in st.session_state:     st.session_state.available_languages = []     logger.debug("Initialisation de st.session_state.available_languages")  # Charger les modèles au démarrage try:     embedding_model = load_embedding_model()     qdrant_client = get_qdrant_client_cached()     ytt = YouTubeTranscriptApi()     logger.info("Tous les modèles et clients chargés avec succès") except Exception as e:     logger.error(f"Erreur lors du chargement des modèles/clients: {e}")     st.error("Erreur lors du chargement de l'application. Veuillez consulter les logs.")  # === SIDEBAR === with st.sidebar:     st.title("🎥 Naive RAG YouTube")     st.markdown("---")          # Input URL     youtube_url = st.text_input("🔗 URL YouTube", placeholder="https://www.youtube.com/watch?v=...")          # Afficher les langues disponibles une fois l'URL saisie     if youtube_url and st.session_state.available_languages:         language_options = {f"{lang['language']} ({lang['language_code']})": lang['language_code']                            for lang in st.session_state.available_languages}         selected_language_display = st.selectbox(             "🌍 Langue de transcription",             options=list(language_options.keys()),             index=0         )         st.session_state.selected_language = language_options[selected_language_display]                  # Afficher les détails sur la langue sélectionnée         selected_lang_info = next((lang for lang in st.session_state.available_languages                                   if lang['language_code'] == st.session_state.selected_language), None)         if selected_lang_info:             lang_type = "générée" if selected_lang_info['is_generated'] else "originale"             st.caption(f"Langue {lang_type}")          # Sélecteur de modèle     selected_model = st.selectbox(         "🤖 Modèle de réponse",         options=AVAILABLE_MODELS,         index=AVAILABLE_MODELS.index(DEFAULT_MODEL) if DEFAULT_MODEL in AVAILABLE_MODELS else 0     )          st.markdown("---")          # Paramètres de génération     st.subheader("⚙️ Paramètres de génération")     st.session_state.temperature = st.slider(         "Température",          min_value=0.0,          max_value=1.0,          value=float(st.session_state.temperature),          step=0.1,         help="Contrôle la créativité de la réponse (0 = déterministe, 1 = créatif)"     )          st.session_state.max_tokens = st.slider(         "Max Tokens",          min_value=100,          max_value=2000,          value=int(st.session_state.max_tokens),          step=100,         help="Longueur maximale de la réponse"     )          st.markdown("---")          if youtube_url:         logger.info(f"Traitement de l'URL YouTube: {youtube_url}")                  # Extraire l'ID et vérifier les langues disponibles         video_id = extract_video_id(youtube_url)         if video_id and not st.session_state.available_languages:             with st.spinner("🔍 Récupération des langues disponibles..."):                 st.session_state.available_languages = get_available_transcript_languages(video_id)                 if st.session_state.available_languages:                     st.success(f"✅ {len(st.session_state.available_languages)} langues trouvées")                 else:                     st.warning("⚠️ Aucune transcription disponible")                  if not video_id:             st.error("❌ URL YouTube invalide")             logger.warning(f"URL YouTube invalide fournie: {youtube_url}")         elif st.session_state.available_languages:             # Vérifier si la vidéo existe déjà avec la langue sélectionnée             logger.info(f"Vérification de l'existence de la vidéo {video_id} en {st.session_state.selected_language} dans Qdrant...")                          # Vérifier si la vidéo existe déjà             video_exists = check_video_exists(qdrant_client, COLLECTION_NAME, video_id)             if video_exists:                 # Vérifier si la langue spécifique existe                 try:                     count_result = qdrant_client.count(                         collection_name=COLLECTION_NAME,                         count_filter=models.Filter(                             must=[                                 models.FieldCondition(                                     key="video_id",                                     match=models.MatchValue(value=video_id)                                 ),                                 models.FieldCondition(                                     key="language",                                     match=models.MatchValue(value=st.session_state.selected_language)                                 )                             ]                         )                     )                     language_exists = count_result.count > 0                                          if language_exists:                         st.success(f"✅ Vidéo déjà traitée en {st.session_state.selected_language} (ID: {video_id})")                         logger.info(f"Vidéo {video_id} déjà présente en {st.session_state.selected_language} dans la base")                         st.session_state.current_video_id = video_id                         st.session_state.video_processed = True                     else:                         st.info(f"🔄 Vidéo traitée mais pas en {st.session_state.selected_language} - Lancement de l'ingestion...")                         logger.info(f"Vidéo {video_id} existe mais pas en {st.session_state.selected_language}")                         video_exists = False  # Forcer le traitement                 except Exception as e:                     logger.error(f"Erreur lors de la vérification de la langue: {e}")                     video_exists = False             else:                 st.info("🔄 Vidéo non traitée - Lancement de l'ingestion...")                 logger.info(f"Vidéo {video_id} non trouvée, démarrage de l'ingestion...")                          if not video_exists:                 # Processus d'ingestion                 try:                     with st.spinner("📥 Récupération de la transcription..."):                         logger.info(f"Récupération de la transcription pour {video_id} en {st.session_state.selected_language}")                         # Essayer d'abord la langue sélectionnée, sinon prendre la première disponible                         try:                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                         except:                             # Si la langue spécifique n'est pas disponible, prendre la première                             first_lang = st.session_state.available_languages[0]['language_code']                             st.warning(f"Langue {st.session_state.selected_language} non disponible, utilisation de {first_lang}")                             st.session_state.selected_language = first_lang                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                                                  logger.info(f"Transcription récupérée ({len(transcript)} segments)")                                          with st.spinner("💾 Sauvegarde de la transcription..."):                         logger.info(f"Sauvegarde de la transcription pour {video_id} en {st.session_state.selected_language}")                         os.makedirs("./downloads", exist_ok=True)                         txt_file_name = f"{video_id}_{st.session_state.selected_language}.txt"                         txt_file_path = f"./downloads/{txt_file_name}"                                                  try:                             save_txt_with_language(transcript, video_id, st.session_state.selected_language, txt_file_name)                             logger.info(f"Transcription sauvegardée dans {txt_file_path}")                         except Exception as e:                             logger.error(f"Erreur lors de la sauvegarde de la transcription pour {video_id}: {e}")                             raise                                          with st.spinner("🧠 Traitement et stockage dans Qdrant..."):                         logger.info(f"Traitement et stockage de {video_id} en {st.session_state.selected_language} dans Qdrant")                         process_and_store_transcript_txt(                             txt_file_path=txt_file_path,                             collection_name=COLLECTION_NAME,                             video_id=video_id,                             language_code=st.session_state.selected_language,                             chunk_size=700,                             chunk_overlap=100                         )                                              with st.spinner("🔍 Vérification du stockage..."):                         # Vérifier le stockage                         try:                             count_result = qdrant_client.count(                                 collection_name=COLLECTION_NAME,                                 count_filter=models.Filter(                                     must=[                                         models.FieldCondition(                                             key="video_id",                                             match=models.MatchValue(value=video_id)                                         ),                                         models.FieldCondition(                                             key="language",                                             match=models.MatchValue(value=st.session_state.selected_language)                                         )                                     ]                                 )                             )                             language_stored = count_result.count > 0                                                          if language_stored:                                 logger.info(f"Vidéo {video_id} en {st.session_state.selected_language} confirmée dans Qdrant")                                 st.success("✅ Vidéo traitée et stockée avec succès!")                                 st.session_state.current_video_id = video_id                                 st.session_state.video_processed = True                             else:                                 logger.warning(f"Vidéo {video_id} en {st.session_state.selected_language} non trouvée dans Qdrant après ingestion")                                 st.warning("⚠️ Problème lors du stockage")                                 st.session_state.video_processed = False                         except Exception as e:                             logger.error(f"Erreur lors de la vérification du stockage: {e}")                             st.session_state.video_processed = False                                      except Exception as e:                     error_msg = f"❌ Erreur lors du traitement: {str(e)}"                     st.error(error_msg)                     logger.error(f"Erreur lors du traitement de la vidéo {video_id}: {e}")                     st.session_state.video_processed = False  # === CHAT INTERFACE === st.title("💬 Chat avec votre vidéo YouTube")  # Afficher l'historique des messages logger.debug(f"Affichage de {len(st.session_state.messages)} messages dans l'historique") for message in st.session_state.messages:     with st.chat_message(message["role"]):         st.markdown(message["content"])  # Input utilisateur if prompt := st.chat_input("Posez votre question sur la vidéo...",                            disabled=not st.session_state.video_processed):          logger.info(f"Question utilisateur: {prompt}")     # Ajouter le message utilisateur     st.session_state.messages.append({"role": "user", "content": prompt})     with st.chat_message("user"):         st.markdown(prompt)          # Réponse de l'assistant     with st.chat_message("assistant"):         message_placeholder = st.empty()         full_response = ""                  try:             if not st.session_state.current_video_id:                 full_response = "❌ Aucune vidéo sélectionnée. Veuillez entrer une URL YouTube dans la sidebar."                 logger.warning("Tentative de question sans vidéo sélectionnée")             else:                 # Récupérer les chunks pertinents avec la langue sélectionnée                 with st.spinner("🔍 Recherche des informations pertinentes..."):                     logger.info(f"Recherche de chunks pertinents pour: {prompt}")                     retrieved_chunks = retrieve_relevant_chunks(                         query=prompt,                         collection_name=COLLECTION_NAME,                         video_id=st.session_state.current_video_id,                         language_code=st.session_state.selected_language,  # Utiliser la langue sélectionnée                         top_k=5                     )                     logger.info(f"Trouvé {len(retrieved_chunks)} chunks pertinents")                                  if not retrieved_chunks:                     full_response = "❌ Je n'ai trouvé aucune information pertinente dans la vidéo pour répondre à votre question."                     logger.info("Aucun chunk pertinent trouvé pour la requête")                 else:                     # Générer la réponse avec l'historique de conversation                     with st.spinner("🤖 Génération de la réponse..."):                         logger.info(f"Génération de réponse avec le modèle {selected_model}")                         full_response = answer_question_with_grok(                             question=prompt,                             chunks=retrieved_chunks,                             model=selected_model,                             max_tokens=st.session_state.max_tokens,                             temperature=st.session_state.temperature,                             conversation_history=st.session_state.messages                         )                         logger.info("Réponse générée avec succès")                          # Afficher la réponse progressivement (effet de frappe)             for chunk in full_response.split():                 full_response += chunk + " "                 time.sleep(0.05)                 message_placeholder.markdown(full_response + "▌")             message_placeholder.markdown(full_response)                      except Exception as e:             error_response = f"❌ Une erreur s'est produite: {str(e)}"             message_placeholder.markdown(error_response)             logger.error(f"Erreur lors de la génération de la réponse: {e}")             full_response = error_response          # Ajouter la réponse à l'historique     st.session_state.messages.append({"role": "assistant", "content": full_response})     logger.debug("Réponse ajoutée à l'historique")  # Bouton pour réinitialiser la conversation if st.sidebar.button("🗑️ Réinitialiser la conversation"):     logger.info("Réinitialisation de la conversation demandée")     st.session_state.messages = []     st.session_state.current_video_id = None     st.session_state.video_processed = False     st.session_state.selected_language = DEFAULT_LANGUAGE     st.session_state.available_languages = []     st.rerun()  logger.info("Fin du rendu de l'application Streamlit")
2025-08-19 13:05:38,308 - __youtube__ - INFO - Extracting video ID from URL: # streamlit_app.py - Version complète mise à jour  import streamlit as st from src.youtube import extract_video_id, get_available_transcript_languages, save_txt_with_language from src.embedding import process_and_store_transcript_txt from src.qdrant import get_qdrant_client, check_video_exists from src.retrieve import retrieve_relevant_chunks from src.query import answer_question_with_grok from src.embedding import get_embedding_model from youtube_transcript_api import YouTubeTranscriptApi from src.loggings import configure_logging import os import time  # Configuration du logging logger = configure_logging(log_file="streamlit_app.log", logger_name="__streamlit_app__") logger.info("Démarrage de l'application Streamlit")  # Configuration de la page st.set_page_config(     page_title="Naive RAG YouTube",     page_icon="🎥",     layout="wide" )  # === CACHING DES MODELES === @st.cache_resource def load_embedding_model():     """Charge le modèle d'embedding au démarrage et le garde en cache"""     with st.spinner("Chargement du modèle d'embedding..."):         logger.info("Chargement du modèle d'embedding...")         model = get_embedding_model()         logger.info("Modèle d'embedding chargé avec succès")         return model  @st.cache_resource def get_qdrant_client_cached():     """Cache le client Qdrant"""     logger.info("Initialisation du client Qdrant...")     client = get_qdrant_client()     logger.info("Client Qdrant initialisé")     return client  # === CONSTANTES === COLLECTION_NAME = "youtube_transcripts" AVAILABLE_MODELS = [     "openai/gpt-oss-120b",     "openai/gpt-oss-20b",      "qwen/qwen3-32b" ] DEFAULT_MODEL = "openai/gpt-oss-120b" DEFAULT_TEMPERATURE = 0.7 DEFAULT_MAX_TOKENS = 1000 DEFAULT_LANGUAGE = "en"  # === INITIALISATION === if 'messages' not in st.session_state:     st.session_state.messages = []     logger.debug("Initialisation de st.session_state.messages") if 'current_video_id' not in st.session_state:     st.session_state.current_video_id = None     logger.debug("Initialisation de st.session_state.current_video_id") if 'video_processed' not in st.session_state:     st.session_state.video_processed = False     logger.debug("Initialisation de st.session_state.video_processed") if 'temperature' not in st.session_state:     st.session_state.temperature = DEFAULT_TEMPERATURE     logger.debug("Initialisation de st.session_state.temperature") if 'max_tokens' not in st.session_state:     st.session_state.max_tokens = DEFAULT_MAX_TOKENS     logger.debug("Initialisation de st.session_state.max_tokens") if 'selected_language' not in st.session_state:     st.session_state.selected_language = DEFAULT_LANGUAGE     logger.debug("Initialisation de st.session_state.selected_language") if 'available_languages' not in st.session_state:     st.session_state.available_languages = []     logger.debug("Initialisation de st.session_state.available_languages")  # Charger les modèles au démarrage try:     embedding_model = load_embedding_model()     qdrant_client = get_qdrant_client_cached()     ytt = YouTubeTranscriptApi()     logger.info("Tous les modèles et clients chargés avec succès") except Exception as e:     logger.error(f"Erreur lors du chargement des modèles/clients: {e}")     st.error("Erreur lors du chargement de l'application. Veuillez consulter les logs.")  # === SIDEBAR === with st.sidebar:     st.title("🎥 Naive RAG YouTube")     st.markdown("---")          # Input URL     youtube_url = st.text_input("🔗 URL YouTube", placeholder="https://www.youtube.com/watch?v=...")          # Afficher les langues disponibles une fois l'URL saisie     if youtube_url and st.session_state.available_languages:         language_options = {f"{lang['language']} ({lang['language_code']})": lang['language_code']                            for lang in st.session_state.available_languages}         selected_language_display = st.selectbox(             "🌍 Langue de transcription",             options=list(language_options.keys()),             index=0         )         st.session_state.selected_language = language_options[selected_language_display]                  # Afficher les détails sur la langue sélectionnée         selected_lang_info = next((lang for lang in st.session_state.available_languages                                   if lang['language_code'] == st.session_state.selected_language), None)         if selected_lang_info:             lang_type = "générée" if selected_lang_info['is_generated'] else "originale"             st.caption(f"Langue {lang_type}")          # Sélecteur de modèle     selected_model = st.selectbox(         "🤖 Modèle de réponse",         options=AVAILABLE_MODELS,         index=AVAILABLE_MODELS.index(DEFAULT_MODEL) if DEFAULT_MODEL in AVAILABLE_MODELS else 0     )          st.markdown("---")          # Paramètres de génération     st.subheader("⚙️ Paramètres de génération")     st.session_state.temperature = st.slider(         "Température",          min_value=0.0,          max_value=1.0,          value=float(st.session_state.temperature),          step=0.1,         help="Contrôle la créativité de la réponse (0 = déterministe, 1 = créatif)"     )          st.session_state.max_tokens = st.slider(         "Max Tokens",          min_value=100,          max_value=2000,          value=int(st.session_state.max_tokens),          step=100,         help="Longueur maximale de la réponse"     )          st.markdown("---")          if youtube_url:         logger.info(f"Traitement de l'URL YouTube: {youtube_url}")                  # Extraire l'ID et vérifier les langues disponibles         video_id = extract_video_id(youtube_url)         if video_id and not st.session_state.available_languages:             with st.spinner("🔍 Récupération des langues disponibles..."):                 st.session_state.available_languages = get_available_transcript_languages(video_id)                 if st.session_state.available_languages:                     st.success(f"✅ {len(st.session_state.available_languages)} langues trouvées")                 else:                     st.warning("⚠️ Aucune transcription disponible")                  if not video_id:             st.error("❌ URL YouTube invalide")             logger.warning(f"URL YouTube invalide fournie: {youtube_url}")         elif st.session_state.available_languages:             # Vérifier si la vidéo existe déjà avec la langue sélectionnée             logger.info(f"Vérification de l'existence de la vidéo {video_id} en {st.session_state.selected_language} dans Qdrant...")                          # Vérifier si la vidéo existe déjà             video_exists = check_video_exists(qdrant_client, COLLECTION_NAME, video_id)             if video_exists:                 # Vérifier si la langue spécifique existe                 try:                     count_result = qdrant_client.count(                         collection_name=COLLECTION_NAME,                         count_filter=models.Filter(                             must=[                                 models.FieldCondition(                                     key="video_id",                                     match=models.MatchValue(value=video_id)                                 ),                                 models.FieldCondition(                                     key="language",                                     match=models.MatchValue(value=st.session_state.selected_language)                                 )                             ]                         )                     )                     language_exists = count_result.count > 0                                          if language_exists:                         st.success(f"✅ Vidéo déjà traitée en {st.session_state.selected_language} (ID: {video_id})")                         logger.info(f"Vidéo {video_id} déjà présente en {st.session_state.selected_language} dans la base")                         st.session_state.current_video_id = video_id                         st.session_state.video_processed = True                     else:                         st.info(f"🔄 Vidéo traitée mais pas en {st.session_state.selected_language} - Lancement de l'ingestion...")                         logger.info(f"Vidéo {video_id} existe mais pas en {st.session_state.selected_language}")                         video_exists = False  # Forcer le traitement                 except Exception as e:                     logger.error(f"Erreur lors de la vérification de la langue: {e}")                     video_exists = False             else:                 st.info("🔄 Vidéo non traitée - Lancement de l'ingestion...")                 logger.info(f"Vidéo {video_id} non trouvée, démarrage de l'ingestion...")                          if not video_exists:                 # Processus d'ingestion                 try:                     with st.spinner("📥 Récupération de la transcription..."):                         logger.info(f"Récupération de la transcription pour {video_id} en {st.session_state.selected_language}")                         # Essayer d'abord la langue sélectionnée, sinon prendre la première disponible                         try:                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                         except:                             # Si la langue spécifique n'est pas disponible, prendre la première                             first_lang = st.session_state.available_languages[0]['language_code']                             st.warning(f"Langue {st.session_state.selected_language} non disponible, utilisation de {first_lang}")                             st.session_state.selected_language = first_lang                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                                                  logger.info(f"Transcription récupérée ({len(transcript)} segments)")                                          with st.spinner("💾 Sauvegarde de la transcription..."):                         logger.info(f"Sauvegarde de la transcription pour {video_id} en {st.session_state.selected_language}")                         os.makedirs("./downloads", exist_ok=True)                         txt_file_name = f"{video_id}_{st.session_state.selected_language}.txt"                         txt_file_path = f"./downloads/{txt_file_name}"                                                  try:                             save_txt_with_language(transcript, video_id, st.session_state.selected_language, txt_file_name)                             logger.info(f"Transcription sauvegardée dans {txt_file_path}")                         except Exception as e:                             logger.error(f"Erreur lors de la sauvegarde de la transcription pour {video_id}: {e}")                             raise                                          with st.spinner("🧠 Traitement et stockage dans Qdrant..."):                         logger.info(f"Traitement et stockage de {video_id} en {st.session_state.selected_language} dans Qdrant")                         process_and_store_transcript_txt(                             txt_file_path=txt_file_path,                             collection_name=COLLECTION_NAME,                             video_id=video_id,                             language_code=st.session_state.selected_language,                             chunk_size=700,                             chunk_overlap=100                         )                                              with st.spinner("🔍 Vérification du stockage..."):                         # Vérifier le stockage                         try:                             count_result = qdrant_client.count(                                 collection_name=COLLECTION_NAME,                                 count_filter=models.Filter(                                     must=[                                         models.FieldCondition(                                             key="video_id",                                             match=models.MatchValue(value=video_id)                                         ),                                         models.FieldCondition(                                             key="language",                                             match=models.MatchValue(value=st.session_state.selected_language)                                         )                                     ]                                 )                             )                             language_stored = count_result.count > 0                                                          if language_stored:                                 logger.info(f"Vidéo {video_id} en {st.session_state.selected_language} confirmée dans Qdrant")                                 st.success("✅ Vidéo traitée et stockée avec succès!")                                 st.session_state.current_video_id = video_id                                 st.session_state.video_processed = True                             else:                                 logger.warning(f"Vidéo {video_id} en {st.session_state.selected_language} non trouvée dans Qdrant après ingestion")                                 st.warning("⚠️ Problème lors du stockage")                                 st.session_state.video_processed = False                         except Exception as e:                             logger.error(f"Erreur lors de la vérification du stockage: {e}")                             st.session_state.video_processed = False                                      except Exception as e:                     error_msg = f"❌ Erreur lors du traitement: {str(e)}"                     st.error(error_msg)                     logger.error(f"Erreur lors du traitement de la vidéo {video_id}: {e}")                     st.session_state.video_processed = False  # === CHAT INTERFACE === st.title("💬 Chat avec votre vidéo YouTube")  # Afficher l'historique des messages logger.debug(f"Affichage de {len(st.session_state.messages)} messages dans l'historique") for message in st.session_state.messages:     with st.chat_message(message["role"]):         st.markdown(message["content"])  # Input utilisateur if prompt := st.chat_input("Posez votre question sur la vidéo...",                            disabled=not st.session_state.video_processed):          logger.info(f"Question utilisateur: {prompt}")     # Ajouter le message utilisateur     st.session_state.messages.append({"role": "user", "content": prompt})     with st.chat_message("user"):         st.markdown(prompt)          # Réponse de l'assistant     with st.chat_message("assistant"):         message_placeholder = st.empty()         full_response = ""                  try:             if not st.session_state.current_video_id:                 full_response = "❌ Aucune vidéo sélectionnée. Veuillez entrer une URL YouTube dans la sidebar."                 logger.warning("Tentative de question sans vidéo sélectionnée")             else:                 # Récupérer les chunks pertinents avec la langue sélectionnée                 with st.spinner("🔍 Recherche des informations pertinentes..."):                     logger.info(f"Recherche de chunks pertinents pour: {prompt}")                     retrieved_chunks = retrieve_relevant_chunks(                         query=prompt,                         collection_name=COLLECTION_NAME,                         video_id=st.session_state.current_video_id,                         language_code=st.session_state.selected_language,  # Utiliser la langue sélectionnée                         top_k=5                     )                     logger.info(f"Trouvé {len(retrieved_chunks)} chunks pertinents")                                  if not retrieved_chunks:                     full_response = "❌ Je n'ai trouvé aucune information pertinente dans la vidéo pour répondre à votre question."                     logger.info("Aucun chunk pertinent trouvé pour la requête")                 else:                     # Générer la réponse avec l'historique de conversation                     with st.spinner("🤖 Génération de la réponse..."):                         logger.info(f"Génération de réponse avec le modèle {selected_model}")                         full_response = answer_question_with_grok(                             question=prompt,                             chunks=retrieved_chunks,                             model=selected_model,                             max_tokens=st.session_state.max_tokens,                             temperature=st.session_state.temperature,                             conversation_history=st.session_state.messages                         )                         logger.info("Réponse générée avec succès")                          # Afficher la réponse progressivement (effet de frappe)             for chunk in full_response.split():                 full_response += chunk + " "                 time.sleep(0.05)                 message_placeholder.markdown(full_response + "▌")             message_placeholder.markdown(full_response)                      except Exception as e:             error_response = f"❌ Une erreur s'est produite: {str(e)}"             message_placeholder.markdown(error_response)             logger.error(f"Erreur lors de la génération de la réponse: {e}")             full_response = error_response          # Ajouter la réponse à l'historique     st.session_state.messages.append({"role": "assistant", "content": full_response})     logger.debug("Réponse ajoutée à l'historique")  # Bouton pour réinitialiser la conversation if st.sidebar.button("🗑️ Réinitialiser la conversation"):     logger.info("Réinitialisation de la conversation demandée")     st.session_state.messages = []     st.session_state.current_video_id = None     st.session_state.video_processed = False     st.session_state.selected_language = DEFAULT_LANGUAGE     st.session_state.available_languages = []     st.rerun()  logger.info("Fin du rendu de l'application Streamlit")
2025-08-19 13:05:47,038 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:05:47,049 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:05:47,056 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: # streamlit_app.py - Version complète mise à jour  import streamlit as st from src.youtube import extract_video_id, get_available_transcript_languages, save_txt_with_language from src.embedding import process_and_store_transcript_txt from src.qdrant import get_qdrant_client, check_video_exists from src.retrieve import retrieve_relevant_chunks from src.query import answer_question_with_grok from src.embedding import get_embedding_model from youtube_transcript_api import YouTubeTranscriptApi from src.loggings import configure_logging import os import time  # Configuration du logging logger = configure_logging(log_file="streamlit_app.log", logger_name="__streamlit_app__") logger.info("Démarrage de l'application Streamlit")  # Configuration de la page st.set_page_config(     page_title="Naive RAG YouTube",     page_icon="🎥",     layout="wide" )  # === CACHING DES MODELES === @st.cache_resource def load_embedding_model():     """Charge le modèle d'embedding au démarrage et le garde en cache"""     with st.spinner("Chargement du modèle d'embedding..."):         logger.info("Chargement du modèle d'embedding...")         model = get_embedding_model()         logger.info("Modèle d'embedding chargé avec succès")         return model  @st.cache_resource def get_qdrant_client_cached():     """Cache le client Qdrant"""     logger.info("Initialisation du client Qdrant...")     client = get_qdrant_client()     logger.info("Client Qdrant initialisé")     return client  # === CONSTANTES === COLLECTION_NAME = "youtube_transcripts" AVAILABLE_MODELS = [     "openai/gpt-oss-120b",     "openai/gpt-oss-20b",      "qwen/qwen3-32b" ] DEFAULT_MODEL = "openai/gpt-oss-120b" DEFAULT_TEMPERATURE = 0.7 DEFAULT_MAX_TOKENS = 1000 DEFAULT_LANGUAGE = "en"  # === INITIALISATION === if 'messages' not in st.session_state:     st.session_state.messages = []     logger.debug("Initialisation de st.session_state.messages") if 'current_video_id' not in st.session_state:     st.session_state.current_video_id = None     logger.debug("Initialisation de st.session_state.current_video_id") if 'video_processed' not in st.session_state:     st.session_state.video_processed = False     logger.debug("Initialisation de st.session_state.video_processed") if 'temperature' not in st.session_state:     st.session_state.temperature = DEFAULT_TEMPERATURE     logger.debug("Initialisation de st.session_state.temperature") if 'max_tokens' not in st.session_state:     st.session_state.max_tokens = DEFAULT_MAX_TOKENS     logger.debug("Initialisation de st.session_state.max_tokens") if 'selected_language' not in st.session_state:     st.session_state.selected_language = DEFAULT_LANGUAGE     logger.debug("Initialisation de st.session_state.selected_language") if 'available_languages' not in st.session_state:     st.session_state.available_languages = []     logger.debug("Initialisation de st.session_state.available_languages")  # Charger les modèles au démarrage try:     embedding_model = load_embedding_model()     qdrant_client = get_qdrant_client_cached()     ytt = YouTubeTranscriptApi()     logger.info("Tous les modèles et clients chargés avec succès") except Exception as e:     logger.error(f"Erreur lors du chargement des modèles/clients: {e}")     st.error("Erreur lors du chargement de l'application. Veuillez consulter les logs.")  # === SIDEBAR === with st.sidebar:     st.title("🎥 Naive RAG YouTube")     st.markdown("---")          # Input URL     youtube_url = st.text_input("🔗 URL YouTube", placeholder="https://www.youtube.com/watch?v=...")          # Afficher les langues disponibles une fois l'URL saisie     if youtube_url and st.session_state.available_languages:         language_options = {f"{lang['language']} ({lang['language_code']})": lang['language_code']                            for lang in st.session_state.available_languages}         selected_language_display = st.selectbox(             "🌍 Langue de transcription",             options=list(language_options.keys()),             index=0         )         st.session_state.selected_language = language_options[selected_language_display]                  # Afficher les détails sur la langue sélectionnée         selected_lang_info = next((lang for lang in st.session_state.available_languages                                   if lang['language_code'] == st.session_state.selected_language), None)         if selected_lang_info:             lang_type = "générée" if selected_lang_info['is_generated'] else "originale"             st.caption(f"Langue {lang_type}")          # Sélecteur de modèle     selected_model = st.selectbox(         "🤖 Modèle de réponse",         options=AVAILABLE_MODELS,         index=AVAILABLE_MODELS.index(DEFAULT_MODEL) if DEFAULT_MODEL in AVAILABLE_MODELS else 0     )          st.markdown("---")          # Paramètres de génération     st.subheader("⚙️ Paramètres de génération")     st.session_state.temperature = st.slider(         "Température",          min_value=0.0,          max_value=1.0,          value=float(st.session_state.temperature),          step=0.1,         help="Contrôle la créativité de la réponse (0 = déterministe, 1 = créatif)"     )          st.session_state.max_tokens = st.slider(         "Max Tokens",          min_value=100,          max_value=2000,          value=int(st.session_state.max_tokens),          step=100,         help="Longueur maximale de la réponse"     )          st.markdown("---")          if youtube_url:         logger.info(f"Traitement de l'URL YouTube: {youtube_url}")                  # Extraire l'ID et vérifier les langues disponibles         video_id = extract_video_id(youtube_url)         if video_id and not st.session_state.available_languages:             with st.spinner("🔍 Récupération des langues disponibles..."):                 st.session_state.available_languages = get_available_transcript_languages(video_id)                 if st.session_state.available_languages:                     st.success(f"✅ {len(st.session_state.available_languages)} langues trouvées")                 else:                     st.warning("⚠️ Aucune transcription disponible")                  if not video_id:             st.error("❌ URL YouTube invalide")             logger.warning(f"URL YouTube invalide fournie: {youtube_url}")         elif st.session_state.available_languages:             # Vérifier si la vidéo existe déjà avec la langue sélectionnée             logger.info(f"Vérification de l'existence de la vidéo {video_id} en {st.session_state.selected_language} dans Qdrant...")                          # Vérifier si la vidéo existe déjà             video_exists = check_video_exists(qdrant_client, COLLECTION_NAME, video_id)             if video_exists:                 # Vérifier si la langue spécifique existe                 try:                     count_result = qdrant_client.count(                         collection_name=COLLECTION_NAME,                         count_filter=models.Filter(                             must=[                                 models.FieldCondition(                                     key="video_id",                                     match=models.MatchValue(value=video_id)                                 ),                                 models.FieldCondition(                                     key="language",                                     match=models.MatchValue(value=st.session_state.selected_language)                                 )                             ]                         )                     )                     language_exists = count_result.count > 0                                          if language_exists:                         st.success(f"✅ Vidéo déjà traitée en {st.session_state.selected_language} (ID: {video_id})")                         logger.info(f"Vidéo {video_id} déjà présente en {st.session_state.selected_language} dans la base")                         st.session_state.current_video_id = video_id                         st.session_state.video_processed = True                     else:                         st.info(f"🔄 Vidéo traitée mais pas en {st.session_state.selected_language} - Lancement de l'ingestion...")                         logger.info(f"Vidéo {video_id} existe mais pas en {st.session_state.selected_language}")                         video_exists = False  # Forcer le traitement                 except Exception as e:                     logger.error(f"Erreur lors de la vérification de la langue: {e}")                     video_exists = False             else:                 st.info("🔄 Vidéo non traitée - Lancement de l'ingestion...")                 logger.info(f"Vidéo {video_id} non trouvée, démarrage de l'ingestion...")                          if not video_exists:                 # Processus d'ingestion                 try:                     with st.spinner("📥 Récupération de la transcription..."):                         logger.info(f"Récupération de la transcription pour {video_id} en {st.session_state.selected_language}")                         # Essayer d'abord la langue sélectionnée, sinon prendre la première disponible                         try:                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                         except:                             # Si la langue spécifique n'est pas disponible, prendre la première                             first_lang = st.session_state.available_languages[0]['language_code']                             st.warning(f"Langue {st.session_state.selected_language} non disponible, utilisation de {first_lang}")                             st.session_state.selected_language = first_lang                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                                                  logger.info(f"Transcription récupérée ({len(transcript)} segments)")                                          with st.spinner("💾 Sauvegarde de la transcription..."):                         logger.info(f"Sauvegarde de la transcription pour {video_id} en {st.session_state.selected_language}")                         os.makedirs("./downloads", exist_ok=True)                         txt_file_name = f"{video_id}_{st.session_state.selected_language}.txt"                         txt_file_path = f"./downloads/{txt_file_name}"                                                  try:                             save_txt_with_language(transcript, video_id, st.session_state.selected_language, txt_file_name)                             logger.info(f"Transcription sauvegardée dans {txt_file_path}")                         except Exception as e:                             logger.error(f"Erreur lors de la sauvegarde de la transcription pour {video_id}: {e}")                             raise                                          with st.spinner("🧠 Traitement et stockage dans Qdrant..."):                         logger.info(f"Traitement et stockage de {video_id} en {st.session_state.selected_language} dans Qdrant")                         process_and_store_transcript_txt(                             txt_file_path=txt_file_path,                             collection_name=COLLECTION_NAME,                             video_id=video_id,                             language_code=st.session_state.selected_language,                             chunk_size=700,                             chunk_overlap=100                         )                                              with st.spinner("🔍 Vérification du stockage..."):                         # Vérifier le stockage                         try:                             count_result = qdrant_client.count(                                 collection_name=COLLECTION_NAME,                                 count_filter=models.Filter(                                     must=[                                         models.FieldCondition(                                             key="video_id",                                             match=models.MatchValue(value=video_id)                                         ),                                         models.FieldCondition(                                             key="language",                                             match=models.MatchValue(value=st.session_state.selected_language)                                         )                                     ]                                 )                             )                             language_stored = count_result.count > 0                                                          if language_stored:                                 logger.info(f"Vidéo {video_id} en {st.session_state.selected_language} confirmée dans Qdrant")                                 st.success("✅ Vidéo traitée et stockée avec succès!")                                 st.session_state.current_video_id = video_id                                 st.session_state.video_processed = True                             else:                                 logger.warning(f"Vidéo {video_id} en {st.session_state.selected_language} non trouvée dans Qdrant après ingestion")                                 st.warning("⚠️ Problème lors du stockage")                                 st.session_state.video_processed = False                         except Exception as e:                             logger.error(f"Erreur lors de la vérification du stockage: {e}")                             st.session_state.video_processed = False                                      except Exception as e:                     error_msg = f"❌ Erreur lors du traitement: {str(e)}"                     st.error(error_msg)                     logger.error(f"Erreur lors du traitement de la vidéo {video_id}: {e}")                     st.session_state.video_processed = False  # === CHAT INTERFACE === st.title("💬 Chat avec votre vidéo YouTube")  # Afficher l'historique des messages logger.debug(f"Affichage de {len(st.session_state.messages)} messages dans l'historique") for message in st.session_state.messages:     with st.chat_message(message["role"]):         st.markdown(message["content"])  # Input utilisateur if prompt := st.chat_input("Posez votre question sur la vidéo...",                            disabled=not st.session_state.video_processed):          logger.info(f"Question utilisateur: {prompt}")     # Ajouter le message utilisateur     st.session_state.messages.append({"role": "user", "content": prompt})     with st.chat_message("user"):         st.markdown(prompt)          # Réponse de l'assistant     with st.chat_message("assistant"):         message_placeholder = st.empty()         full_response = ""                  try:             if not st.session_state.current_video_id:                 full_response = "❌ Aucune vidéo sélectionnée. Veuillez entrer une URL YouTube dans la sidebar."                 logger.warning("Tentative de question sans vidéo sélectionnée")             else:                 # Récupérer les chunks pertinents avec la langue sélectionnée                 with st.spinner("🔍 Recherche des informations pertinentes..."):                     logger.info(f"Recherche de chunks pertinents pour: {prompt}")                     retrieved_chunks = retrieve_relevant_chunks(                         query=prompt,                         collection_name=COLLECTION_NAME,                         video_id=st.session_state.current_video_id,                         language_code=st.session_state.selected_language,  # Utiliser la langue sélectionnée                         top_k=5                     )                     logger.info(f"Trouvé {len(retrieved_chunks)} chunks pertinents")                                  if not retrieved_chunks:                     full_response = "❌ Je n'ai trouvé aucune information pertinente dans la vidéo pour répondre à votre question."                     logger.info("Aucun chunk pertinent trouvé pour la requête")                 else:                     # Générer la réponse avec l'historique de conversation                     with st.spinner("🤖 Génération de la réponse..."):                         logger.info(f"Génération de réponse avec le modèle {selected_model}")                         full_response = answer_question_with_grok(                             question=prompt,                             chunks=retrieved_chunks,                             model=selected_model,                             max_tokens=st.session_state.max_tokens,                             temperature=st.session_state.temperature,                             conversation_history=st.session_state.messages                         )                         logger.info("Réponse générée avec succès")                          # Afficher la réponse progressivement (effet de frappe)             for chunk in full_response.split():                 full_response += chunk + " "                 time.sleep(0.05)                 message_placeholder.markdown(full_response + "▌")             message_placeholder.markdown(full_response)                      except Exception as e:             error_response = f"❌ Une erreur s'est produite: {str(e)}"             message_placeholder.markdown(error_response)             logger.error(f"Erreur lors de la génération de la réponse: {e}")             full_response = error_response          # Ajouter la réponse à l'historique     st.session_state.messages.append({"role": "assistant", "content": full_response})     logger.debug("Réponse ajoutée à l'historique")  # Bouton pour réinitialiser la conversation if st.sidebar.button("🗑️ Réinitialiser la conversation"):     logger.info("Réinitialisation de la conversation demandée")     st.session_state.messages = []     st.session_state.current_video_id = None     st.session_state.video_processed = False     st.session_state.selected_language = DEFAULT_LANGUAGE     st.session_state.available_languages = []     st.rerun()  logger.info("Fin du rendu de l'application Streamlit")
2025-08-19 13:05:47,061 - __youtube__ - INFO - Extracting video ID from URL: # streamlit_app.py - Version complète mise à jour  import streamlit as st from src.youtube import extract_video_id, get_available_transcript_languages, save_txt_with_language from src.embedding import process_and_store_transcript_txt from src.qdrant import get_qdrant_client, check_video_exists from src.retrieve import retrieve_relevant_chunks from src.query import answer_question_with_grok from src.embedding import get_embedding_model from youtube_transcript_api import YouTubeTranscriptApi from src.loggings import configure_logging import os import time  # Configuration du logging logger = configure_logging(log_file="streamlit_app.log", logger_name="__streamlit_app__") logger.info("Démarrage de l'application Streamlit")  # Configuration de la page st.set_page_config(     page_title="Naive RAG YouTube",     page_icon="🎥",     layout="wide" )  # === CACHING DES MODELES === @st.cache_resource def load_embedding_model():     """Charge le modèle d'embedding au démarrage et le garde en cache"""     with st.spinner("Chargement du modèle d'embedding..."):         logger.info("Chargement du modèle d'embedding...")         model = get_embedding_model()         logger.info("Modèle d'embedding chargé avec succès")         return model  @st.cache_resource def get_qdrant_client_cached():     """Cache le client Qdrant"""     logger.info("Initialisation du client Qdrant...")     client = get_qdrant_client()     logger.info("Client Qdrant initialisé")     return client  # === CONSTANTES === COLLECTION_NAME = "youtube_transcripts" AVAILABLE_MODELS = [     "openai/gpt-oss-120b",     "openai/gpt-oss-20b",      "qwen/qwen3-32b" ] DEFAULT_MODEL = "openai/gpt-oss-120b" DEFAULT_TEMPERATURE = 0.7 DEFAULT_MAX_TOKENS = 1000 DEFAULT_LANGUAGE = "en"  # === INITIALISATION === if 'messages' not in st.session_state:     st.session_state.messages = []     logger.debug("Initialisation de st.session_state.messages") if 'current_video_id' not in st.session_state:     st.session_state.current_video_id = None     logger.debug("Initialisation de st.session_state.current_video_id") if 'video_processed' not in st.session_state:     st.session_state.video_processed = False     logger.debug("Initialisation de st.session_state.video_processed") if 'temperature' not in st.session_state:     st.session_state.temperature = DEFAULT_TEMPERATURE     logger.debug("Initialisation de st.session_state.temperature") if 'max_tokens' not in st.session_state:     st.session_state.max_tokens = DEFAULT_MAX_TOKENS     logger.debug("Initialisation de st.session_state.max_tokens") if 'selected_language' not in st.session_state:     st.session_state.selected_language = DEFAULT_LANGUAGE     logger.debug("Initialisation de st.session_state.selected_language") if 'available_languages' not in st.session_state:     st.session_state.available_languages = []     logger.debug("Initialisation de st.session_state.available_languages")  # Charger les modèles au démarrage try:     embedding_model = load_embedding_model()     qdrant_client = get_qdrant_client_cached()     ytt = YouTubeTranscriptApi()     logger.info("Tous les modèles et clients chargés avec succès") except Exception as e:     logger.error(f"Erreur lors du chargement des modèles/clients: {e}")     st.error("Erreur lors du chargement de l'application. Veuillez consulter les logs.")  # === SIDEBAR === with st.sidebar:     st.title("🎥 Naive RAG YouTube")     st.markdown("---")          # Input URL     youtube_url = st.text_input("🔗 URL YouTube", placeholder="https://www.youtube.com/watch?v=...")          # Afficher les langues disponibles une fois l'URL saisie     if youtube_url and st.session_state.available_languages:         language_options = {f"{lang['language']} ({lang['language_code']})": lang['language_code']                            for lang in st.session_state.available_languages}         selected_language_display = st.selectbox(             "🌍 Langue de transcription",             options=list(language_options.keys()),             index=0         )         st.session_state.selected_language = language_options[selected_language_display]                  # Afficher les détails sur la langue sélectionnée         selected_lang_info = next((lang for lang in st.session_state.available_languages                                   if lang['language_code'] == st.session_state.selected_language), None)         if selected_lang_info:             lang_type = "générée" if selected_lang_info['is_generated'] else "originale"             st.caption(f"Langue {lang_type}")          # Sélecteur de modèle     selected_model = st.selectbox(         "🤖 Modèle de réponse",         options=AVAILABLE_MODELS,         index=AVAILABLE_MODELS.index(DEFAULT_MODEL) if DEFAULT_MODEL in AVAILABLE_MODELS else 0     )          st.markdown("---")          # Paramètres de génération     st.subheader("⚙️ Paramètres de génération")     st.session_state.temperature = st.slider(         "Température",          min_value=0.0,          max_value=1.0,          value=float(st.session_state.temperature),          step=0.1,         help="Contrôle la créativité de la réponse (0 = déterministe, 1 = créatif)"     )          st.session_state.max_tokens = st.slider(         "Max Tokens",          min_value=100,          max_value=2000,          value=int(st.session_state.max_tokens),          step=100,         help="Longueur maximale de la réponse"     )          st.markdown("---")          if youtube_url:         logger.info(f"Traitement de l'URL YouTube: {youtube_url}")                  # Extraire l'ID et vérifier les langues disponibles         video_id = extract_video_id(youtube_url)         if video_id and not st.session_state.available_languages:             with st.spinner("🔍 Récupération des langues disponibles..."):                 st.session_state.available_languages = get_available_transcript_languages(video_id)                 if st.session_state.available_languages:                     st.success(f"✅ {len(st.session_state.available_languages)} langues trouvées")                 else:                     st.warning("⚠️ Aucune transcription disponible")                  if not video_id:             st.error("❌ URL YouTube invalide")             logger.warning(f"URL YouTube invalide fournie: {youtube_url}")         elif st.session_state.available_languages:             # Vérifier si la vidéo existe déjà avec la langue sélectionnée             logger.info(f"Vérification de l'existence de la vidéo {video_id} en {st.session_state.selected_language} dans Qdrant...")                          # Vérifier si la vidéo existe déjà             video_exists = check_video_exists(qdrant_client, COLLECTION_NAME, video_id)             if video_exists:                 # Vérifier si la langue spécifique existe                 try:                     count_result = qdrant_client.count(                         collection_name=COLLECTION_NAME,                         count_filter=models.Filter(                             must=[                                 models.FieldCondition(                                     key="video_id",                                     match=models.MatchValue(value=video_id)                                 ),                                 models.FieldCondition(                                     key="language",                                     match=models.MatchValue(value=st.session_state.selected_language)                                 )                             ]                         )                     )                     language_exists = count_result.count > 0                                          if language_exists:                         st.success(f"✅ Vidéo déjà traitée en {st.session_state.selected_language} (ID: {video_id})")                         logger.info(f"Vidéo {video_id} déjà présente en {st.session_state.selected_language} dans la base")                         st.session_state.current_video_id = video_id                         st.session_state.video_processed = True                     else:                         st.info(f"🔄 Vidéo traitée mais pas en {st.session_state.selected_language} - Lancement de l'ingestion...")                         logger.info(f"Vidéo {video_id} existe mais pas en {st.session_state.selected_language}")                         video_exists = False  # Forcer le traitement                 except Exception as e:                     logger.error(f"Erreur lors de la vérification de la langue: {e}")                     video_exists = False             else:                 st.info("🔄 Vidéo non traitée - Lancement de l'ingestion...")                 logger.info(f"Vidéo {video_id} non trouvée, démarrage de l'ingestion...")                          if not video_exists:                 # Processus d'ingestion                 try:                     with st.spinner("📥 Récupération de la transcription..."):                         logger.info(f"Récupération de la transcription pour {video_id} en {st.session_state.selected_language}")                         # Essayer d'abord la langue sélectionnée, sinon prendre la première disponible                         try:                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                         except:                             # Si la langue spécifique n'est pas disponible, prendre la première                             first_lang = st.session_state.available_languages[0]['language_code']                             st.warning(f"Langue {st.session_state.selected_language} non disponible, utilisation de {first_lang}")                             st.session_state.selected_language = first_lang                             transcript = ytt.fetch(video_id=video_id, languages=[st.session_state.selected_language])                                                  logger.info(f"Transcription récupérée ({len(transcript)} segments)")                                          with st.spinner("💾 Sauvegarde de la transcription..."):                         logger.info(f"Sauvegarde de la transcription pour {video_id} en {st.session_state.selected_language}")                         os.makedirs("./downloads", exist_ok=True)                         txt_file_name = f"{video_id}_{st.session_state.selected_language}.txt"                         txt_file_path = f"./downloads/{txt_file_name}"                                                  try:                             save_txt_with_language(transcript, video_id, st.session_state.selected_language, txt_file_name)                             logger.info(f"Transcription sauvegardée dans {txt_file_path}")                         except Exception as e:                             logger.error(f"Erreur lors de la sauvegarde de la transcription pour {video_id}: {e}")                             raise                                          with st.spinner("🧠 Traitement et stockage dans Qdrant..."):                         logger.info(f"Traitement et stockage de {video_id} en {st.session_state.selected_language} dans Qdrant")                         process_and_store_transcript_txt(                             txt_file_path=txt_file_path,                             collection_name=COLLECTION_NAME,                             video_id=video_id,                             language_code=st.session_state.selected_language,                             chunk_size=700,                             chunk_overlap=100                         )                                              with st.spinner("🔍 Vérification du stockage..."):                         # Vérifier le stockage                         try:                             count_result = qdrant_client.count(                                 collection_name=COLLECTION_NAME,                                 count_filter=models.Filter(                                     must=[                                         models.FieldCondition(                                             key="video_id",                                             match=models.MatchValue(value=video_id)                                         ),                                         models.FieldCondition(                                             key="language",                                             match=models.MatchValue(value=st.session_state.selected_language)                                         )                                     ]                                 )                             )                             language_stored = count_result.count > 0                                                          if language_stored:                                 logger.info(f"Vidéo {video_id} en {st.session_state.selected_language} confirmée dans Qdrant")                                 st.success("✅ Vidéo traitée et stockée avec succès!")                                 st.session_state.current_video_id = video_id                                 st.session_state.video_processed = True                             else:                                 logger.warning(f"Vidéo {video_id} en {st.session_state.selected_language} non trouvée dans Qdrant après ingestion")                                 st.warning("⚠️ Problème lors du stockage")                                 st.session_state.video_processed = False                         except Exception as e:                             logger.error(f"Erreur lors de la vérification du stockage: {e}")                             st.session_state.video_processed = False                                      except Exception as e:                     error_msg = f"❌ Erreur lors du traitement: {str(e)}"                     st.error(error_msg)                     logger.error(f"Erreur lors du traitement de la vidéo {video_id}: {e}")                     st.session_state.video_processed = False  # === CHAT INTERFACE === st.title("💬 Chat avec votre vidéo YouTube")  # Afficher l'historique des messages logger.debug(f"Affichage de {len(st.session_state.messages)} messages dans l'historique") for message in st.session_state.messages:     with st.chat_message(message["role"]):         st.markdown(message["content"])  # Input utilisateur if prompt := st.chat_input("Posez votre question sur la vidéo...",                            disabled=not st.session_state.video_processed):          logger.info(f"Question utilisateur: {prompt}")     # Ajouter le message utilisateur     st.session_state.messages.append({"role": "user", "content": prompt})     with st.chat_message("user"):         st.markdown(prompt)          # Réponse de l'assistant     with st.chat_message("assistant"):         message_placeholder = st.empty()         full_response = ""                  try:             if not st.session_state.current_video_id:                 full_response = "❌ Aucune vidéo sélectionnée. Veuillez entrer une URL YouTube dans la sidebar."                 logger.warning("Tentative de question sans vidéo sélectionnée")             else:                 # Récupérer les chunks pertinents avec la langue sélectionnée                 with st.spinner("🔍 Recherche des informations pertinentes..."):                     logger.info(f"Recherche de chunks pertinents pour: {prompt}")                     retrieved_chunks = retrieve_relevant_chunks(                         query=prompt,                         collection_name=COLLECTION_NAME,                         video_id=st.session_state.current_video_id,                         language_code=st.session_state.selected_language,  # Utiliser la langue sélectionnée                         top_k=5                     )                     logger.info(f"Trouvé {len(retrieved_chunks)} chunks pertinents")                                  if not retrieved_chunks:                     full_response = "❌ Je n'ai trouvé aucune information pertinente dans la vidéo pour répondre à votre question."                     logger.info("Aucun chunk pertinent trouvé pour la requête")                 else:                     # Générer la réponse avec l'historique de conversation                     with st.spinner("🤖 Génération de la réponse..."):                         logger.info(f"Génération de réponse avec le modèle {selected_model}")                         full_response = answer_question_with_grok(                             question=prompt,                             chunks=retrieved_chunks,                             model=selected_model,                             max_tokens=st.session_state.max_tokens,                             temperature=st.session_state.temperature,                             conversation_history=st.session_state.messages                         )                         logger.info("Réponse générée avec succès")                          # Afficher la réponse progressivement (effet de frappe)             for chunk in full_response.split():                 full_response += chunk + " "                 time.sleep(0.05)                 message_placeholder.markdown(full_response + "▌")             message_placeholder.markdown(full_response)                      except Exception as e:             error_response = f"❌ Une erreur s'est produite: {str(e)}"             message_placeholder.markdown(error_response)             logger.error(f"Erreur lors de la génération de la réponse: {e}")             full_response = error_response          # Ajouter la réponse à l'historique     st.session_state.messages.append({"role": "assistant", "content": full_response})     logger.debug("Réponse ajoutée à l'historique")  # Bouton pour réinitialiser la conversation if st.sidebar.button("🗑️ Réinitialiser la conversation"):     logger.info("Réinitialisation de la conversation demandée")     st.session_state.messages = []     st.session_state.current_video_id = None     st.session_state.video_processed = False     st.session_state.selected_language = DEFAULT_LANGUAGE     st.session_state.available_languages = []     st.rerun()  logger.info("Fin du rendu de l'application Streamlit")
2025-08-19 13:05:52,687 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:05:52,698 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:05:52,705 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 13:05:52,706 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=WMeOZAHusGQ
2025-08-19 13:05:52,707 - __youtube__ - ERROR - Erreur lors de la récupération des langues pour WMeOZAHusGQ: type object 'YouTubeTranscriptApi' has no attribute 'list_transcripts'
2025-08-19 13:05:52,710 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 13:06:45,153 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:06:45,167 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:06:45,171 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=OLXkGB7kr
2025-08-19 13:06:45,171 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=OLXkGB7kr
2025-08-19 13:06:45,172 - __youtube__ - ERROR - Erreur lors de la récupération des langues pour OLXkGB7kr: type object 'YouTubeTranscriptApi' has no attribute 'list_transcripts'
2025-08-19 13:06:45,174 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 13:10:44,211 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:10:44,219 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:10:44,229 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=OLXkGB7kr
2025-08-19 13:10:44,229 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=OLXkGB7kr
2025-08-19 13:10:44,232 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo OLXkGB7kr en en dans Qdrant...
2025-08-19 13:10:44,642 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 404 Not Found"
2025-08-19 13:10:44,649 - __qdrant__ - ERROR - Error checking existence of video OLXkGB7kr: Unexpected Response: 404 (Not Found)
Raw response content:
b'{"status":{"error":"Not found: Collection `youtube_transcripts` doesn\'t exist!"},"time":0.000016825}'
2025-08-19 13:10:44,652 - __streamlit_app__ - INFO - Vidéo OLXkGB7kr non trouvée, démarrage de l'ingestion...
2025-08-19 13:10:44,653 - __streamlit_app__ - INFO - Récupération de la transcription pour OLXkGB7kr en en
2025-08-19 13:10:46,154 - __streamlit_app__ - ERROR - Erreur lors du traitement de la vidéo OLXkGB7kr: 
Could not retrieve a transcript for the video https://www.youtube.com/watch?v=OLXkGB7kr! This is most likely caused by:

The video is no longer available

If you are sure that the described cause is not responsible for this error and that a transcript should be retrievable, please create an issue at https://github.com/jdepoix/youtube-transcript-api/issues. Please add which version of youtube_transcript_api you are using and provide the information needed to replicate the error. Also make sure that there are no open issues which already describe your problem!
2025-08-19 13:10:46,158 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 13:10:54,991 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:10:54,998 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:10:55,017 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
2025-08-19 13:10:57,581 - __streamlit_app__ - INFO - Démarrage de l'application Streamlit
2025-08-19 13:10:57,585 - __streamlit_app__ - INFO - Tous les modèles et clients chargés avec succès
2025-08-19 13:10:57,590 - __streamlit_app__ - INFO - Traitement de l'URL YouTube: https://www.youtube.com/watch?v=OLXkGB7kr
2025-08-19 13:10:57,590 - __youtube__ - INFO - Extracting video ID from URL: https://www.youtube.com/watch?v=OLXkGB7kr
2025-08-19 13:10:57,592 - __streamlit_app__ - INFO - Vérification de l'existence de la vidéo OLXkGB7kr en en dans Qdrant...
2025-08-19 13:10:57,978 - httpx - INFO - HTTP Request: POST https://8944ab11-ce5f-4e99-9520-02d24272ba30.europe-west3-0.gcp.cloud.qdrant.io:6333/collections/youtube_transcripts/points/count "HTTP/1.1 404 Not Found"
2025-08-19 13:10:57,980 - __qdrant__ - ERROR - Error checking existence of video OLXkGB7kr: Unexpected Response: 404 (Not Found)
Raw response content:
b'{"status":{"error":"Not found: Collection `youtube_transcripts` doesn\'t exist!"},"time":4.564e-6}'
2025-08-19 13:10:57,981 - __streamlit_app__ - INFO - Vidéo OLXkGB7kr non trouvée, démarrage de l'ingestion...
2025-08-19 13:10:57,982 - __streamlit_app__ - INFO - Récupération de la transcription pour OLXkGB7kr en en
2025-08-19 13:10:59,426 - __streamlit_app__ - ERROR - Erreur lors du traitement de la vidéo OLXkGB7kr: 
Could not retrieve a transcript for the video https://www.youtube.com/watch?v=OLXkGB7kr! This is most likely caused by:

The video is no longer available

If you are sure that the described cause is not responsible for this error and that a transcript should be retrievable, please create an issue at https://github.com/jdepoix/youtube-transcript-api/issues. Please add which version of youtube_transcript_api you are using and provide the information needed to replicate the error. Also make sure that there are no open issues which already describe your problem!
2025-08-19 13:10:59,428 - __streamlit_app__ - INFO - Fin du rendu de l'application Streamlit
